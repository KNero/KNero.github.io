# 1MB 어드레스와 A20 게이트

앞절에서 설명한 PC에서 부팅이 되지 않는 이유는 아래와 같다.

초창기 XT PC는 최대 1MB의 어드레스에 접근할 수 있었지만 리얼 모드에서는 세그먼트와 오프셋으로 1MB가 넘는 영역을 접근할 수 있었다.
하지만 하드웨어의 한계로 1MB가 넘는 어드레스로 접근하는 경우 하위 어드레스만 남아 0xFFFF로 인식되었다.

시간이 지나 16MB 어드레스까지 접근할 수 있는 AT PC가 등장하며 기존 XT PC용 프로그램을 실행하는데 문제가 생겼는데 AT PC는
1MB 이상의 어드레스를 1MB이하의 어드레스에 매핑을 시켰기 때문이었다.

이것을 해결하기 위해서 사용한 방법이 A20 게이트로 어드레스의 20번째 비트를 뜻하며, A20의 역할은 20번째 비트를 활성화 하거나 비활성화하여 XT PC의 어드레스 계산 방식과
호환성을 유지시킨다. 어드레스 라인의 20번째(1MB의 위치)가 항상 0으로 고정되므로 선형 주소가 0x10FFEF가 되더라도 0xFFEF로 처리할 수 있다.

AT PC는 부팅 과정을 완료하고 나서 A20 게이트를 무조건 0으로 설정하여 XT PC와 호환을 유지했으며, A20 게이트를 활성화했을 때만 20번째 어드레스 비트가 정상적으로
동작하게 했다. (~~게이트 들어가는 단어는 뭔가 역할이...~~)

A20 게이트가 비활성화된 상태에서는 어드레스 라인의 20번째 비트가 항상 0으로 설정되므로 홀수 MB에는 접근할 수 없다.
```
3MB + 64KB = 0x310000
0011 0001 0000 0000 0000 0000

실제로 접근할 때는 아래로 변환

0010 0001 0000 0000 0000 0000
2MB + 64KB = 0x210000
```

간혹 최신 BIOS 중에서는 A20게이트를 사용하지 않거나 기본 값으로 1로 설정하기 때문에 실행이 되는 경우도 있다.
A20 게이트를 활성화 하는 방법은 크게 세 가지가 있다.

- Keyboard Controller 로 활성화
- System Control Port 로 활성화
- BIOS 서비스로 활성화

## System Control Port 사용

**시스템 컨트롤 포트의 각 비트와 의미**

| 비트           | 읽기/쓰기 모드  | 설명         |
| ------------- |-------------|-------------|
| 7 | 읽기, 쓰기 | - 하드디스크 LED 제어 |
| 6 |          | - 모두 0으로 설정하면 LED가 꺼지며, 그 외의 경우에는 LED가 켜짐|
| 5 | -        | - 사용 안 함|
| 4 |          |           |
| 3 | 읽기, 쓰기 | - 부팅 패스워드 접근 제어 |
|   |         | - 1로 설정하면 전원을 다시 인가할 때까지 CMOS 레지스터(0x38 ~ 0x3F)에 설정된 부팅 패스워드를 삭제하지 못하며, 0으로 설정하면 부팅 패스워드를 삭제할 수 있음|
| 2 | 읽기 전용 | - 사용 안 함 |
| 1 | 일기 전용 | - A20 게이트 제어 |
|   |         | - 1로 설정하면 A20 게이트를 활성화하며, 0으로 설정하면 A20 게이트를 비활성화 함 |
| 0 | 쓰기 전용 | - 빠른 시스템 리셋 |
|   |         | - 1로 설정하면 시스템 리셋(리얼 모드로 전환)을 수행하며, 0으로 설정하면 아무 변화 없음 |

이제 비트 1만 1로 설정할 것이다. x86 프로세서는 I/O 포트에 접근하는 in/out 명령어를 통해서 A20 게이트를 활성화할 수 있다.

```
in al, 0x92	    ; 시스템 컨트롤 포트(0x92)에서 1바이트를 읽어 AL 레지스터에 저장

or al, 0x02     ; 읽은 값에 A20 게이트 비트(비트 1)를 1로 설정
and al, 0xFF    ; 시스템 리셋 방지를 위해 0xFF와 AND 연산하여 비트 0를 0으로 설정

out 0x92, al    ; 시스템 컨트롤 포트(0x92)에 변경된 값을 1바이트 설정
```

## BIOS 서비스 사용

**BIOS의 시스템 서비스(0x15)중 A20 게이트 관련 기능 목록**
| AX 레지스터 값 | 설명 | 상태 |
| ------------- |-------------|-------------|
| 0x2400 | - A20 게이트 비활성화 | - 성공이면 EFLAGS 레지스터의 CF 비트=0, AH 레지스터=0 |
| 0x2401 | - A20 게이트 활성화 | 실패이면 EFLAGS 레지스터의 CF 비트=1, AH 레지스터=0x80 or 0x86 |
| 0x2402 | - A20 게이트 상태 읽기 | - 성공이면 EFLAGS 레지스터의 CF 비트=0, AH 레지스터=0, AL 레지스터=활성화(1) or 비활성화(0) |
|        |                    | 실패이면 EFLAGS 레지스터의 CF 비트=1, AH 레지스터=0x80 or 0x86 |
| 0x2403 | - A20 게이트 지원 유무 | - 성공이면 EFLAGS 레지스터의 CF 비트=0, AH 레지스터=0, BX 레지스터= 키보드 컨트롤 포트 지원(1) or 시트템 컨트롤 포트 지원(2) |
|        |                    | 실패이면 EFLAGS 레지스터의 CF 비트=1, AH 레지스터=0x80 or 0x86 |

```
mov ax, 0x2401      ; A20 게이트 활성화 서비스 설정
int 0x15            ; BIOS 인터럽트 서비스 호출

jc .A20GATERROR     ; A20 게이트 활성화가 성공했는지 확인 (A20 게이트 활성화가 실패하면 EFLAGS 레지스터의 CF 비트가 1로 설정되므로 이를 검사하여 에러 처리 코드로 이동)
jmp .A20GATESUCCESS

.A20GATERROR:
  ...에러 처리...

.A20GATESUCCESS:
  ...성공 처리...
```

두 가지 모두를 사용하여 검사를 할 것이고 BIOS 서비스를 먼저 사용하고 실패하면 시스템 컨트롤 포트를 사용하도록 할 것이다.

[EntryPoint.s](https://github.com/KNero/os-study/blob/master/01.Kernel32/Source/EntryPoint.s)소스에서 상단의 A20관련된 부분을 확인하면
변경된 코드를 확인할 수 있다. 나는 이 부분을 USB를 통해서 부팅을 확인하지 않고 변경 후 기존 QEMU에서 정상적으로 부팅되는 지만 확인했다.

이제 1MB 이상의 메모리에 접근할 수 있게 되었으니 메모리 크기 검사 기능을 추가할 것이다.