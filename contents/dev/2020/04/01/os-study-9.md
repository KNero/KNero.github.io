# 리얼모드에서 보호모드로

리얼모드에서 보호모드로 전환하기 위해서는 크게 6단계를 거쳐야 하는데 상위 2단계는 보호 모드 전환에 필요한 자료구조를 생성하는 단계, 나머지 4단계는 생성된 자료구조를 프로세서에 설정하는 단계이다.

1. 세그먼트 디스크립터 생성 (보호 모드 코드와 데이터용 세그먼트 디스크립터 생성)
2. GDT 정보 생성 (세그먼트 디스크립터의 시작 어드레스와 디스크립터의 전체 크기 저장)
3. 프로세서에 GDT 정보 설정 (GDTR 레지스터에 GDT의 시작 어드레스와 크기 설정)
4. CR0 컨트롤 레지스터 설정 (CR0 컴트롤 레지스터의 PE 비트=1, PG=0)
5. jmp 명령으로 CS 세그먼트 셀렉터 변경과 보호 모드로 전환 (jmp 0x08: 보호 모드 커널의 시작 어드레스)
6. 각종 세그먼트 셀렉터 및 스택 초기화 (DS, ES, FS, GS, SS 세그먼트 셀렉터와 ESP, EBP 레지스터 초기화)
7. 보호 모드 커널 실행
(1 ~ 5 는 16비트 리얼 모드, 6부터는 32비트 보호 모드)

## 세그먼트 디스크립터 생성

Segment Descriptor는 세그먼테이션 기법(메모리 관리 기법)에서 세그먼트의 정보를 나타내는 자료구조이다. 세그먼트는 메모리 공간을 임의의 크기로 나눈 영역을 의미하며,
세그먼트를 복잡하게 구성할 수록 세그먼트 디트크립터의 수도 증가한다. MINT64 OS에서는 보호 모드의 기본 기능만 사용하므로 4GB 전체 메모리 공간을 지정하는 커널 코드와
데이터 세그먼트만 사용한다.

코드 세그먼트: 실행 가능한 코드가 포함된 세그먼트 (CS 세그먼트 셀렉터에 사용)
데이터 세그먼트: 데이터가 포함된 세그먼트에 대한 정보를 나타낸다 (CS 세그먼트 셀렉터를 제외한 나머지 셀렉터에 상용)

**리얼 모드에서 사용하던 세그먼트 레지스터라는 명칭은 보호 모드에서 세그먼트 셀렉터라는 이름으로 바뀌었다. 이름만 바뀌었고 같은 레지스터이다.**

### 세그먼트 디스크립터의 구조
![segment descriptor](/contents/dev/2020/04/01/image/os-study-9-1.png)

**기준 주소**

- 세그먼트의 시작 어드레스
- 32비트 크기이며, 0바이트 ~ 4GB까지 설정 가능

**세그먼트 크기**

- 세그먼트의 크기
- 20비트 크기
- G비트가 0으로 설정되면 0바이트 ~ 1MB까지 설정가능
- G비트가 1로 설정되면 4KB를 곱하여 0바이트 ~ 4GB까지 설정가능

**타입**

- 세그먼트 타입
- 코드 또는 데이터 세그먼트로 설정 가능

**S**

- 디스크립터의 타입
- 1로 설정할 경우 세그먼트 디스크립터를 나타내며, 0으로 설정하면 시스템 디스크립터를 나타냄

**DPL**

- Descriptor Privilege Level의 약자로 해당 디스크립터를 사용에 필요한 권한을 의미
- 0(Highest) ~ 3(Lowest)의 범위를 가짐
- CPL(Current Privilege Level)나 RPL(Requested Privilege Level)과 조합되어 접근 권한을 제한하는 데 사용

**P**

- Present의 의미로 현재 디스크립터가 유효한 디스크립터인지 표시
- 1로 설정하면 유효한 디스크립터임을 나타내며, 0으로 설정하면 유효하지 않은 디스크립터임을 나타냄

**AVL**

- Available의 약자로 OS가 임의의 용도로 사용할 수 있는 영역

**L**

- IA-32e 모드에서 사용하는 필드로 64비트 코드 세그먼트나 32비트 코드 세그먼트를 의미
- 1로 설정하면 IA-32e 모드의 64비트용 코드 세그먼트임을 나타내며, 0으로 설정하면 IA-32e 모드의 32비트 호한 모드용코드 세그먼트임을 나타냄

**D/B**

- Default Operation Size를 의미
- 1로 설정하면 32비트용 세그먼트임을 나타내며, 0으로 설정하면 16비트용 세그먼트임을 나타냄

**G**

- Granularity의 약자로 디스크립터의 세그먼트 크기 필드에 곱해질 가중치를 의미
- 1로 설정하면 세그먼트 크기에 4KB를 곱하며, 0으로 설정하면 가중치를 곱하지 않음

이제 이 많은 필드 중 설정할 값을 찾기 위해 우리가 설정하고자 하는 세그먼트에 대해 정리해 보겠다.
- 커널 코드와 데이터용 세그먼트 디스크립터 각 1개
- 커널 코드와 데이터용 세그먼트는 0 ~ 4GB까지 모든 영역에 접근할 수 있어야 함
- 보호 모드용 코드와 데이터에 사용할 기본 오퍼랜드 크기는 32비트여야 함
- 보호 기능은 사용하지 않으며, 프로세서의 명령을 사용하는 데 제약이 없어야 하므로 최상위 권한(0)이어야 함

### 필드값 세팅

- 코드 세그먼트와 데이터 세그먼트는 세그먼트 디스크립터이므로 S를 1로 설정
- 코드 세그먼트 타입은 0x0A(Execute/Read), 데이터 세그먼트 타입은 0x02(Read/Write)
- 세그먼트 디스크립터는 4GB 전체 영역에 접근할 수 있어야 하므로 커널용 세그먼트 기준 주소는 0, G필드는 1 (크기 필드 20비트 * 4KB = 4GB)
- 기본 오퍼랜드의 크기를 32비트로 설정하기 위해 D/B 필드를 1로, 보호 모드용이므로 L비트는 0
- MINT64 OS의 보호 모드는 권한을 따로 구분하지 않으므로 권한 필드는 모두 최상위 권한(0)
- 디스크립터가 유효함을 나타내는 P는 1
- AVL은 사용하지 않으므로 0

### 커널 코드 세그먼트와 데이터 세그먼트 디스크립터 생성 코드

```
    CODEDESCRIPTOR:
        dw 0xFFFF   ; Limit [15:0]
        dw 0x0000   ; Base [15:0]
        db 0x00     ; Base [23:16]
        db 0x9A     ; P=1, DPL=0, Code Segment, Execute/Read
        db 0xCF     ; G=1, D=1, L=0, Limit[19:16]
        db 0x00     ; Base [31, 24]

    DATADESCRIPTOR:
        dw 0xFFFF   ; Limit [15:0]
        dw 0x0000   ; Base [15:0]
        db 0x00     ; Base [23:16]
        db 0x92     ; P=1, DPL=0, Data Segment, Read/Write
        db 0xCF     ; G=1, D=1, L=0, Limit[19:16]
        db 0x00     ; Base [31, 24]
```

---

64비트 IA-32e 모드로 전환하려면 반드시 32비트 보호 모드를 거쳐야 한다. 보호 모드는 4GB의 주소공간, 멀티태스킹, 페이징, 메모리 보호 등의 기능을 하드웨어적으로 지원한다.
하지만 여기서는 64비트로 전환하기 위한 임시 모드로 사용되며 다음에는 생성한 디스크립터를 이용해서 GDT 자료구조를 생성할 것이다.
