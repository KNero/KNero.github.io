# 플로피 디스크에서 OS 이미지를 로딩하자

책의 5장에서는 OS의 이미지를 메모리로 복사하기가 나오는데 여기서 BIOS의 도움을 받아 플로피 디스크의 이미지를 메모리로 로딩하는 방법이 추가된다.
이전에 (부트로더 만들기)[https://knero.github.io/#/contents?path=/contents/dev/2020/03/20/os-study-5.md&date=2020.03.20] 에서 OS 이미지를 하드 디스크를 사용해서 로딩하도록  `-hda` 로 변경해서 사용해 왔지만 이제는 다시 플로피 디스크에 이미지를 로딩하기 위해 책에서와 같이 `-fda`로 변경했다.

**변경정**
```
qemu-system-x86_64 -L . -m 64 -hda ./Disk.img -localtime -display curses
```

**변경후**
```
qemu-system-x86_64 -L . -m 64 -fda ./Disk.img -localtime -display curses
```

이렇게 사용하며 첫 번째 floppy disk 마운트해서 기동해 준다.

## BIOS 사용

BIOS 는 키보드/마우스에서 디스크나 프린터까지 거의 모든 PC 주변기기를 제어하는 기능을 함수의 어드레스를 인터럽트 벡터 테이블(Interrupt Vector Table)에 넣어 두고, 소프트웨어 인터럽트(SWI, Software Interrupt)를 호출하는 방법을 사용하여 제공해 준다. 자세한 내용은 책을 참고하거나 리얼 모드에서의 인터럽트 벡터 테이블을 검색해서 확인해 보면 되며 디스크 서비스를 이용하려면 `0x13` 인터럽트를 사용해야 하는데 이것은 `Disk I/O Service` 이다. 

인터럽트를 발생시켜야 한다는 것은 우리가 임의로 인터럽트를 발생시킬 수 있어야 한다는 것을 의미하며 이때 소프트웨어 인터럽트 명령을 사용한다.
SWI는 CPU에 가상으로 특정 인터럽트가 발생했다고 알리는 명령어로 int 0x13 형태로 사용한다. 우리가 만든 함수의 어드레스를 인터럽트 벡터 테이블에 넣어뒀다면 int 명령으로 언제든지 해당 함수로 이동할 수 있다.

그리고 관련된 파라미터는 레지스터를 통해서 전달하며 AX, BX, CX, DX 레지스터와 ES 세그먼트 레지스터를 사용하고 결과값도 레지스터를 통해서 넘겨 받는다.

또한 플로피 디스크는 자기 원반(Magnetic Disk)으로 구성된 저장 매체로 트랙과 섹터로 구성돼 있고 이를 헤더를 통해서 읽는 방식이다. 자세한 플로피 디스크의 구조와 읽는 방법은 검색을 해보길 권한다.
**(여기서는 섹터 하나의 크기가 512바이트로 구성된다는 사실만 알고 가자.)**

## 디스크 읽기

MINT64 OS의 이미지는 크게 부트 로더, 보호 모드 커널, IA-32e 모드 커널로 구성되며, 각 부분은 섹터 단위로 정렬해서 하나의 부팅 이미지 파일로 합친다. 따라서 디스크의 두 번째 섹터부터 읽어서 특정 메모리 어드레스에 순서대로 복사하면 이미지 로딩은 끝이다. 여기서 0x10000 하위 영역을 다른 용도로 사용하기위해 OS 이미지를 0x10000(64Kbyte)에 로딩해서 실행한다.

플로피 디스크의 첫 번째 섹터는 부트 로더로 BIOS가 메모리에 로딩한다. 따라서 플로피 디스크의 두 번째 섹터부터 OS 이미지 크기만큼을 읽어서 메모리에 복사하면 된다. 플로피 디스크는 `트랙과 섹터 그리고 앞면과 뒷면`으로 구성되어 있다.

## 함수 구현

여기서 한 가지 알아야할 것이 있는데 바로 함수를 구현하는 것이다. (디스크 읽는 것을 바로 구현할 줄 알았는데 함수라니..)
디스크의 데이터를 복사하더라도 화면에 출력되는 문자가 너무 적어 심심한데(?!) 단계별로 문자를 출력하면 더 보기 좋고 이를 위해 함수를 구현해서 사용해 볼 것이다.

x86 프로세서에서 함수를 사용하려면 Last-In, First-Out 구조인 Stack이 꼭 필요한데 함수를 호출한 코드의 다음 어드레스, 즉 되돌아갈 어드레스를 저장하는 용도로 스택을 사용한다.

함수를 호출(call)하면 프로세서가 자동으로 되돌아올 어드레스를 스택에 저장하며, 호출된 함수에서 되돌아감(ret)을 요청하면 자동으로 스택에서 어드레스를 꺼내 호출한 다음 어드레스로 이동하는 것이다.
또한 스택은 함수의 파라미터를 저장하는 역할도 겸한다. 그리고 관련 레지스터는 3개가 있다.

- 스택 세그먼트 레지스터(SS): 스택 영역으로 사용할 세그먼트의 기준 주소
- 스택 포인터 레지스터(SP): 데이터를 삽입하고 제거하는 상위(Top)를 지정
- 베이스 포인터 레지스터(BP): 스택의 기준 주소를 임시로 지정

16비트 모드는 세그먼테이션 방식으로 어드레스를 변환하므로 스택 세그먼트 레지스터를 사용해서 최대 64KB를 스택 영역으로 지정할 수 있다.

#### 레지스터들의 관계
![stack register](//knero.github.io/contents/dev/2020/03/25/image/os-study-7-1.png)

스택을 사용할 영역은 0x10000(64KB) 부터는 OS 이미지가 로딩되므로 0x10000이하, 즉 0x0000:0000 ~ 0x0000:FFFF 이다. 따라서 그림에서와 같이 설정하면 된다.
그리고 파라미터는 X좌표, Y좌표, 출력할 문자열 어드레스가 필요하므로 이 세 가지를 스택에 차례로 넣을 것이다.

**함수에 관련된 설명들은 굉장히 많고 요약하기 힘들었다. 블로그의 기록은 이론보다는 실제 구현하는 코드에 집중하며 작성하기 때문에 더 자세한 내용은 책을 참고하길 바란다.**
OS 이미지가 정상적으로 로딩되었다면 0x10000 위치로 이동해서 보호 모드 커널 코드를 실행하도록했다.
주석위주로 천천히 코드를 읽어보기 바란다.

**BootLoader.asm**
```
[ORG 0x00]  ; 코드의 시작 어드레스를 0x00 으로 설정
[BITS 16]   ; 이하의 코드는 16비트 코드로 설정

SECTION .txt    ; text 섹션(세그먼트)을 정의

jmp 0x07C0:START    ; CS 세그먼트 레지스터에 0x07C0을 복사하면서 START 레이블로 이동

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; MINT64 OS에 관련된 환경설정 값
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
TOTALSECTORCOUNT: dw 1024   ; 부트 로더를 제외한 MINT64 OS 이미지의 크기. 최대 1152 세터 (0x90000byte) 까지 가능

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 코드 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
START:
    mov ax, 0x07C0  ; 부트 로더의 시작 어드레스(0x07C0)을 세그먼트 레지스터 값으로 변환, AX(산술연산 시 누산기로 사용)
    mov ds, ax      ; DS(데이터 관련 세그먼트 레지스터) 세그먼트 레지스터에 설정
    mov ax, 0xB800  ; 비디오 메모리의 시작 어드레스(0xB800)을 세그먼트 레지스터 값으로 변환
    mov es, ax      ; ES(문자열 관련 세그먼트 레지스터) 세그먼트 레지스터에 설정

    ; 스택을 0x0000:0000 ~ 0x0000:FFFF 영역에 64KB 크기로 생성
    mov ax, 0x0000  ;스택 세그먼트의 시작 어드레스 (0x0000)를 세그먼트 레지스터 값으로 변환
    mov ss, ax      ; SS(스택영역을 가리키는 세그먼트 레지스터) 세그먼트 레지스터에 저장
    mov sp, 0xFFFE  ; SP(스텍의 포인터로 사용되는 범용 레지스터) 세그먼터의 어드레스를 0xFFFE 로 설정
    mov bp, 0xFFFE  ; BP(스택의 데이터로 접근할 때 사용하는 범용 레지스터) 레지스터의 어드레스를 0xFFFE 로 설정

    ; 화면을 모두 지우고, 속성값을 녹색으로 설정
    mov si, 0       ; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화

.SCREENCLEARLOOP:
    mov byte[es: si], 0         ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제
    mov byte[es: si + 1], 0x0A  ; 비디오 메모리의 속성이 위치하는 어드레스에 0x0A(검은 바탕에 밝은 녹색)을 복사
    add si, 2                   ; 문자와 속성을 설정했으므로 다음 위치로 이동

    cmp si, 80 * 25 * 2         ; 화면의 전체 크기를 80문자 * 25라인임. 출력한 문자의 수를 의미하는 SI 레지스터와 비교
    jl .SCREENCLEARLOOP         ; SI 레지스터가 80 * 25* 2 보다 작다면 아직 지우지 못한 영역이 있으므로 루프를 반복

; 화면 상단에 시작 메시지 출력
push MESSAGE1       ; 화면에 출력할 메시지 어드레스를 스택에 삽입
push 0              ; 화면에 Y 좌표(0)를 스택에 삽입
push 0              ; 화면에 X 좌표(0)를 스택에 삽입
call PRINTMESSAGE   ; 메시지 출력 함수 호출
add sp, 6           ; 파라미터 제거 (스택은 높은 어드레스에서 작은 어드레스로 쌓이기 때문에 6을 더하면 삽입된 파라미터 3개가 삭제된다. 2바이트 * 3)

; OS 이미지를 로딩한다는 메시지 출력
push IMAGELOADINGMESSAGE
push 1
push 0
call PRINTMESSAGE
add sp, 6

; 디스크에서 OS 이미지를 로딩
; 디스크를 읽기 전에 먼저 리셋
RESETDISK:
	; BIOS Reset Function 호출
	; 서비스 번호 0, 드라이브 번호 0
    mov ax, 0
    mov dl, 0
    int 0x13
    ; 에러가 발생하면 에러 처리로 이동
    jc HANDLEDISKERROR

    ; 디스크에서 섹터를 읽음
    ; 디스크의 내용을 메모리로 복사할 어드레스(ES:BX)를 0x10000 으로 설정
    mov si, 0x1000  ; 이미지를 복사할 어드레스를 세그먼트 값으로 변환
    mov es, si      ; ES 세그먼트 레지스터에 값 설정
    mov bx, 0x0000  ; BX 레지스터에 0x0000을 설정하여 복사할 어드레스를 0x1000:0000(0x10000)으로 최종 설정

    mov di, word[TOTALSECTORCOUNT] ; 복사할 os 이미지의 섹터 수를 DI 레지스터에 설정

READDATA:   ; 디스크를 읽는 코드를 시작
	; 모든 섹터를 다 읽었는지 확인
    cmp di, 0   ; 복사할 OS 이미지의 섹터 수를 0과 비교
    je READEND  ; 복사할 섹터 수가 0이라면 다 복사했으므로 READEND 로 이동
    sub di, 0x01    ; 복사할 섹터 수를 1 감소

    ; BIOS Read Function 호출
    mov ah, 0x02    ; BIOS 서비스 번호 2(Read Sector)
    mov al, 0x1     ; 읽을 섹터 수는 1
    mov ch, byte[TRACKNUMBER]   ; 읽을 트랙 번호 설정
    mov cl, byte[SECTORNUMBER]  ; 읽을 섹터 번호 설정
    mov dh, byte[HEADNUMBER]    ; 읽을 헤드 번호를 설정
    mov dl, 0x00                ; 읽을 드라이브 번호(0=Floppy) 설정
    int 0x13                    ; 인터럽트 서비스 수행
    jc HANDLEDISKERROR          ; 에러가 발생했다면 이동

    ; 복사할 어드레스와 트랙, 헤드, 섹터 어드레스 계산
    add si, 0x0020  ; 512(0x200)바이트 만큼 읽었으므로 이를 세그먼트 레지스터 값으로 변환
    mov es, si      ; ES 세그먼트 레지스터에 더해서 어드레스를 한 섹터 만큼 증가

    ; 한 섹터를 읽었으므로 섹터 번호를 증가시키고 마지막 섹터(18)까지 읽었는지 판단
    ; 마지막 섹터가 아니면 섹터 읽기로 이동해서 다시 섹터 읽기 수행
    mov al, byte[SECTORNUMBER]
    add al, 0x01    ;섹터 번호를 1증가
    mov byte[SECTORNUMBER], al
    cmp al, 19
    jl READDATA

    ; 마지막 섹터까지 읽었으면 헤드를 토글(0 > 1, 1, > 0)하고 섹터 번호를 1로 설정
    xor byte[HEADNUMBER], 0x01
    mov byte[SECTORNUMBER], 0x01

    ; 만약 헤드가 1->0 로 바뀌었으면 양쪽헤드를 모두 읽은 것이므로 아래로 이동하여 트랙 번호를 1 증가
    cmp byte[HEADNUMBER], 0x00
    jne READDATA

    ; 트랙을 1 증가시킨 후 다시 섹터 읽기로 이동
    add byte[TRACKNUMBER], 0x01
    jmp READDATA
READEND:

; OS 이미지가 완료되었다는 메시지 출력
push LOADINGCOMPLETEMESSAGE
push 1
push 20
call PRINTMESSAGE
add sp, 6

; 로딩한 가상 OS 이미지 실행
jmp 0x1000:0x0000

HANDLEDISKERROR:
    push DISKERRORMESSAGE
    push 1
    push 20
    call PRINTMESSAGE
    add sp, 6

jmp $   ; 현재 위치에서 무한 루프 수행

; 메시지 출력함수
; param: x, y, 문자열
PRINTMESSAGE:
    push bp         ; 베이스 포인터 레지스터(BP)를 스택에 삽입
    mov bp, sp      ; 베이스 포인터 레지스터에(BP)에 스택 포인터 레지스터(SP)의 값을 설정
                    ; 베이스 포인터 레지스터를 이용해서 파라미터에 접근할 목적
    push ES 		; ES 세그먼트 레지스터부터 DX 레지스터까지 스택에 삽입
    push si 		; 함수에서 임시로 사용하는 레지스터로 함수의 마지막 부분에서
    push di 		; 스택에 삽입된 값을 꺼내 원래 값으로 복원
    push ax
    push cx
    push dx

    ; ES 세그먼트 레지스터에 비디오 모드 어드레스 설정
    mov ax, 0xB800	; 비디오 메모리 시작 어드레스를 세그먼트 레지스터 값으로 변환
    mov es, ax 		; ES 세그먼트 레지스터에 설정

    ; X, Y 의 좌표로 비디오 메모리의 어드레스를 계산함
    ; Y 좌표를 이용해서 먼저 라인 어드레스를 구함
    mov ax, word[bp + 6]    ; 파라미터 2(화면 좌표 Y) 를 AX 레지스터에 설정
    mov si, 160             ; 한 라인의 바이트 수(2 * 80)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 Y 어드레스 계산
    mov di, ax              ; 계산된 화면 Y 어드레스를 DI 레지스터에 설정

    mov ax, word[bp + 4]    ; 파라미터 1(화면 좌표 X) 를 AX 레지스터에 설정
    mov si, 2               ; 한 문자를 나타내는 바이트 수(2)를 SI 레지스터에 설정
    mul si                  ; AX 레지스터와 SI 레지스터를 곱하여 화면 X 어드레스 계산
    add di, ax              ; 화면 Y 어드레스와 계산된 X 어드레스를 더해서 실제 비디오 메모리 어드레스를 계산

    mov si, word[bp + 8]    ; 파라미터 3(출력할 문자열의 어드레스)

.MESSAGELOOP:
    mov cl, byte[si]    ; MESSAGE1의 어드레스에서 SI 레지스터 값만큼 더한 위치의 문자를 CL 레지스터에 복사
                        ; CL 레지스터는 CX 레지스터의 하위 1바이트만 사용
                        ; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용
    cmp cl, 0       ; 복사된 문자와 0을 비교
    je .MESSAGEEND  ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

    mov byte[es: di], cl    ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di 에 문자를 출력

    inc si      ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2   ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동. 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로
    jmp .MESSAGELOOP

.MESSAGEEND:
    pop dx  ; 함수에서 사용이 끝난 DX 레지스터 부터 EX 레지스터까지를 스탤에
    pop cx  ; 삽입된 값을 이용해서 복원
    pop ax  ; 스택은 가장 마지막에 들어간 데이터가 가장 먼저 나오는
    pop di  ; 자료구조이므로 삽입의 역순으로 제거해야 함
    pop si  ; 제거해야 함
    pop es
    pop bp  ; 베이스 포인터 레지스터(BP) 복원
    ret     ; 함수를 호출한 다음 코드의 위치로 복귀

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; 데이터 영역
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
MESSAGE1: db 'MINT64 OS Boot Loader Start', 0    ; 출력할 메시지 정의.
                                                 ; 마지막은 0으로 설정하여 .MESSAGELOOP 에서 문자열이 종료되었음을 알 수 있도록 함.
MESSAGE2: db 'Processing initialize operating system...', 0
IMAGELOADINGMESSAGE: db 'OS Image Loading...', 0
LOADINGCOMPLETEMESSAGE: db 'Complete', 0
DISKERRORMESSAGE: db 'Disk Error!', 0

SECTORNUMBER: db 0x02   ; OS 이미지가 시작하는 섹터 번호를 저장하는 영역
HEADNUMBER: db 0x00     ; OS 이미지가 시작하는 헤드 번호를 저장하는 영역
TRACKNUMBER: db 0x00    ; OS 이미지가 시작하는 트랙 번호를 저장하는 영역

times 510 - ( $ - $$ )  db  0x00    ; $: 현재 라인의 어드레스
                                    ; $$: 현재 섹션 (.text)의 시작 어드레스
                                    ; $ - $$ : 현재 섹션을 기준으로 하는 오프셋
                                    ; 510 - ( $ - $$ ): 현재부터 어드레스 510 까지
                                    ; db 0x00: 1바이트를 선언하고 값은 0x00
                                    ; time: 반복 수행
                                    ; 현재 위치에서 어드레스 510 까지 0x00 으로 채움

db 0x55 ; 1 바이트를 선언하고 값은 0x55
db 0xAA ; 1 바이트를 언언하고 값은 0xAA
        ; 어드레스 511, 512 에 0x55, 0xAA 를 써서 부트섹터로 표기함
```

여기까지하고 실행하면 검은색 화면만 나오는데 이유는 커널 이미지가 없기 때문이다. 이미지 로딩 기능을 구현할 때 부트 로더를 제외한 나머지 섹터의 크기를 1024로 설정했으므로 부트 로더를 포함해서 최소한 1025개 이상의 섹터로 구성된 OS 이미지가 필요하다. 지금은 테스트 단계이므로 가상OS를 만들어 보겠다.

-> 이것은 다음 스터디에 할 것이다.
