# 운영 모드와 메모리 관리 기법

이전 글인 [**운영 모드와 레지스터**](https://knero.github.io/#/contents?path=/contents/dev/200312/os-study-2.md&date=2020.03.12)보다 이번에 다룰
메모리 관리 기법은 내용이 너무 많은 관계로 최대한 축약해서 정리하려고 한다. 
**운영 모드와 레지스터**도 너무 많이 줄여서 글을 보면서 공부하기는 어렵고 검색하거나 책을 추가로 봐야 하지만 메모리 관리 기법은 더 어려울 듯 싶다.

## Segmentation & Paging

둘의 차이는 주소 공간을 나눈다는 공통점이 있지만 **세그먼테이션은 전체 영역을 원하는 크기로 나누어 관리하는 방식**이고, 
**페이징은 일정한 단위로 잘라진 조각을 모아 원하는 크기로 관리하는 방식**이다.

메모리 관리 기법을 사용하려면 관련 레지스터에 특정한 자료구조를 설정해야 한다. 세그먼테이션은 세그먼트 레지스터의 시작 주소 혹은
디스크립터(Descriptor)라고 불리는 자료구조의 위치를 설정해야 한다. 페이징은 컨트롤 레지스터 중 CR3 레지스터에 페이지 디렉터리라고 불리는
자료구조의 물리 주소를 설정해야 사용할 수 있다.

### 리얼 모드

리얼 모드는 최대 1MB까지 주소 공간을 사용하며 세그먼테이션만 지원한다. 세그먼트 크기는 64K로 고정이고 세그먼트의 시작 어드레스는 세그먼트 레지스터에 직접 설정한다.
세그먼테이션에서 세그먼트의 시작 어드레스는 코드나 메모리에 접근할 때 기준 어드레스(Base Address)로 사용된다. 

리얼 모드에서는 페이징을 사용하지 않기 때문에 세그먼테이션을 거쳐 나온 어드레스가 물리 주소가 된다. 리얼 모드에서는 세그먼트 레지스터의 값에 범용 레지스터의 값을 더하는 방식으로 동작하게 되는데 둘 다 16비트인 레지스터를 사용하여 1MB영역까지 접근하기 위해 세그먼트 레지스터의 값에 16을 곱한 값을 세그먼트의 기준 주소로 사용한다.

```
16비트 최대값 65535 * 16 = 1048560 (1MB 에 근접한 값)
```

계산법은

```
0x1000 (세그먼트 레지스터) * 16 + 0x1234 (범용레지스터) = 0x11234 (물리주소)
```

세그먼트 크기가 64KB 인 이유는 범용레지스터가 모두 16비트 이기 때문인데 16비트로 접근할 수 있는 범위가 0 ~ 65535(0xffff) 이므로 64KB 가 됐다.
세그먼트에 16을 곱한 위치가 기준 주소가 되고 그 주소부터 최대 64K 까지 이동할 수 있기 때문이다.

![real mode segmentation](//knero.github.io/contents/dev/2020/03/13/image/os-study-3-1.png)

### 보호 모드

보호 모드는 세그먼테이션과 페이징을 지원 하는데 리얼모드의 세그먼테이션보다 많은 기능을 제공한다. 또한 세그먼트의 기준 주소를 직접 설정하는 대신 디스크립터 자료구조의
위치(Offset)를 설정하는 방식으로 바뀌었다. 세그먼트 레지스터의 명칭도 디스크립터를 선택한다는 의미에서 세그먼트 셀렉터로 변경되었다.

세그먼트 디스크립터는 GDT 라고 불리는 곳에 모여 있는데 GDT 는 연속된 디스크립터의 집힙이다. (관련있는 레지스터는 GDTR)

보호 모드에 세그멘테이션에서 주소를 계산하는 방법은 리얼 모드와 마찬가지로 세그먼트 레지스터의 기준 주소에 범용 레지스터의 값을 더해서 구한다. 또한 보호 모드에서는 리얼 모드와 달리 세그먼트의 크기가 64KB 로 고정되어 있지 않고 지정할 수 있다.

![protect mode segmentation](//knero.github.io/contents/dev/2020/03/13/image/os-study-3-2.png)

결과로 나오는 선형 주소는 물리 주소와 일치할 수도, 그렇지 않을 수도 있는데 결과값은 페이징의 입력 값이 되며, 페이징을 사용하지 않는다면 물리 주소와 1:1로 대응한다.

페이징은 물리 메모리를 페이지(Page)라고 불리는 일정한 크기로 나누고, 선형 주소와 물리 주소를 나눠놓는 페이지로 연결하는 방식을 말한다. 더 큰 영역의 선형 주소도 물리 페이지만 연결하면 사용이 가능하므로, 주소 공간을 넓게 사용할 수 있는 장점이 있다. 또한 같은 물리 페이지를 여러 선형 주소에 연결 함으로써 응용프로그램끼리 공유하는 메모리를 손쉽게 처리할 수 있다.

결과로 나오는 선형 주소를 페이지 디렉터리와 페이지 테이블을 사용하여 물리 주소와 매핑하게 되는데 이 부분은 따로 검색해보기를 권한다.

(세그먼트에 의해서 메모리 영역이 데이터 영역, 코드 영역 등으로 나누어 지는 것에 주목하자. 데이터 영역에서 코드가 실행되면 안되는데 이것은 해킹에서 사용된다.)

### IA-32e 모드의 메모리 관리

IA-32e 모드는 64비트 이므로 최대 어드레스가 2^64, 즉 16EB(Exa Byte) 까지이다. 세그먼테이션은 보호모드와 큰 차이가 없고 두 가지 차이가 있는데 기준 주소와 크기에 관계없이 모든 세그먼트가 기준 주소는 0, 크기는 64비트 전체로 설정되며 다른 하나는 두 가지 서브모드를 지원하므로 이를 구분하고자 세그먼트 디스크립터에 L 필드(비트21)가 추가되었다. 이 필드를 0으로 설정하면 호환 모드로 1로 설정하면 64비트 모드로 동작한다.

---

여기까지 해서 준비과정의 설명은 끝났다고 한다. 공부를 하면서 궁금한 점들을 이것저것 찾아봤는데 내 컴퓨터가 동작한다는 것 자체가 신기할 정도로 프로세서의 동작이 너무 복잡하고 섬세했다.
아직 궁금한 점들이 많이 있지만 앞으로 개발을 하며 천천히 알아갈 것이다.
