# 화면 버퍼

화면에 환영 문구와 같은 문자를 출력해 볼 것이다. 이를 위해서는 화면 모드와 관련된 비디오 메모리의 어드레스를 알아야 한다. 비디오 메모리는 화면 출력과 관련된 메모리로 모드별로 정해진 형식에 따라 데이터를 채우면 화면에 문자나 그림을 출력하는 구조로 되어 있다.

부팅 후 기본적으로 설정되는 화면 모드는 텍스트 모드로 가로 80문자, 세로 25문자이며 비디오 메모리 어드레스는 `0xB8000`에서 시작한다. **한 문자는 문자값 1바이트와 속성값 1바이트**로 구성되며 총 메모리 크기는 80 * 25 * 2 = 4,000바이트이다.

##### 비디오 메모리 어드레스 구조: 문자1바이트 + 속성1바이트 + 문자1바이트 + 속성1바이트 ...

### 속성값 1바이트

- 하위 4비트: 전경색 (상위 1비트 특수기능 + 하위 3비트 색상) / 특수기능: 강조
- 상위 4비트: 배경색 (상위 1비트 특수기능 + 하위 3비트 색상) / 특수기능: 강조, 깜빡임

#### 상위 1비트 특수기능

- 0x00: 효과없음
- 0x01: 배경색일 경우 깜빡인 효과(Blink)나 강조효과(밝기 상승), 전경색일 경우 강조효과 추가

#### 하위 3비트 색상

- 0x00: 검은색
- 0x01: 파란색
- 0x02: 녹색
- 0x03: 청색
- 0x04: 빨간색
- 0x05: 자홍색
- 0x06: 노란색
- 0x07: 흰색

이제 출력을 해볼려고 한다. 리얼 모드의 어드레스 계산 방식은 세그먼트 레지스터에 정의된 기준 주소에 값을 더해 계산한다고 했었다. 따라서 0xB8000 어드레스에 접근하려면
세그먼트 레지스터에 세그먼트의 기준 주소부터 설정해야 한다. 그러나 세그먼트 레지스터의 값을 0xB800 으로 설정하며 세그먼트 레지스터:오프셋이 0xB800:0x0000 이 되어 범용 레지스터의 0을 비디오 메모리의 첫 번째 어드레스로 지정할 수 있어서 편리하다.

세그먼트 레지스터에 0xB800 을 설정하는 코드는 아래와 같이 mov 명령을 이용하면 간단히 처리할 수 있다.

```
mov ax, 0xB800 ; AX 레지스터에 0xB800 복사
mov ds, ax     ; DS 세그먼트 레지스터에 AX 레지스터의 값을 복사
```

그리고 어셈블리어에서 어드레스에 해당하는 메모리 값을 참조할 때 `[ ]` 기호를 사용하며 기호 앞에 byte, word(2바이트), dword(4바이트), qword(8바이트)를 사용하여 메모리 크기를 지정한다.

```
mov byte[0x00], 'M'  ; DS 세그먼트:오프셋 0xB800:0x0000 에 'M'을 복사
mov byte[0x01], 0x4A ; DS 세그먼트:오프셋 0xB800:0x0001 에 0x4A(빨간 배경에 녹색 속성)을 복사
```

# 환영문자 출력

문자를 출력하는 코드 이전에 세그먼트 레지스터를 초기화 하는 코드가 필요하다. 이유는 BIOS가 부트로더를 실행했을 때 세그먼트 레지스터에는 BIOS가 사용하던 값이 들어있기 때문이다.

여기서는 0x07C0으로 초기화 하는데 **BIOS가 부트 로더를 디스크에서 읽어 메모리에 복사하는 위치가 0x7C00이기 때문이다.** 또한 부트 로더의 코드(Code Segment)와 데이터(Data Segment)는 0x7C00부터 512바이트 범위에 존재하므로 CS와 DS 세그먼트 레지스터를 모두 0x7C0으로 설정했다. 하지만 CS 세그먼트 레지스터는 mov 명령으로 처리할 수 없으며, 수정하려면 jmp 명령과 세그먼트 레지스터 접두사를 이용해야 한다. 

다음은 jmp, mov 을 사용하여 세그먼트를 초기화 하는 코드이다. CS, DS 세그먼트 레지스터는 0x7C0을 설정하여 부트로더의 시작을 기준으로 하도록 했으며, ES 세그먼트 레지스터는 화면 출력에 관련된 세그먼트로 사용하려고 0xB800을 설정했다. 

비디오 모드에 관련된 세그먼트 레지스터가 DS 세그먼트 레지스터에서 ES 세그먼트 레지스터로 변경되었으니 이후 출력에 관계된 코드는 모두 ES 세그먼트 레지스터를 기준으로 하게 수정해야 한다. 별다른 처리가 없다면 암시저으로 DS 세그먼트를 사용하지만 `[세그먼트 레지스터:오프셋]` 형식으로 사용하면 ES 세그먼트 레지스터를 사용할 수 있다.

#### BootLoader.asm
```
[ORG 0x00]  ; 코드의 시작 어드레스를 0x00 으로 설정
[BITS 16]   ; 이하의 코드는 16비트 코드로 설정

SECTION .txt    ; text 섹션(세그먼트)을 정의

jmp 0x07C0:START    ; CS 세그먼트 레지스터에 0x07C0을 복사하면서 START 레이블로 이동

START:
    mov ax, 0x07C0  ; 부트 로더의 시작 어드레스(0x07C0)을 세그먼트 레지스터 값으로 변환
    mov ds, ax      ; DS(데이터 관련 세그먼트 레지스터) 세그먼트 레지스터에 설정
    mov ax, 0xB800  ; 비디오 메모리의 시작 어드레스(0xB800)을 세그먼트 레지스터 값으로 변환
    mov es, ax      ; ES(문자열 관련 세그먼트 레지스터) 세그먼트 레지스터에 설정

    mov si, 0       ; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화

.SCREENCLEARLOOP:               ; 화면을 지우는 루프
    mov byte[es: si], 0         ; 비디오 메모리의 문자가 위치하는 어드레스에 0을 복사하여 문자를 삭제
    mov byte[es: si + 1], 0x0A  ; 비디오 메모리의 속성이 위치하는 어드레스에 0x0A(검은 바탕에 밝은 녹색)을 복사
    add si, 2                   ; 문자와 속성을 설정했으므로 다음 위치로 이동

    cmp si, 80 * 25 * 2         ; 화면의 전체 크기를 80문자 * 25라인임. 출력한 문자의 수를 의미하는 SI 레지스터와 비교
    jl .SCREENCLEARLOOP         ; SI 레지스터가 80 * 25* 2 보다 작다면 아직 지우지 못한 영역이 있으므로 루프를 반복

    mov si, 0   ; SI 레지스터(문자열 원본 인덱스 레지스터)를 초기화
    mov di, 0   ; DI 레지스터(문자열 대상 인덱스 레지스터)를 초기화

.MESSAGELOOP:                      ; 메시지를 출력하는 루프
    mov cl, byte[si + MESSAGE1]    ; MESSAGE1의 어드레스에서 SI 레지스터 값만큼 더한 위치의 문자를 CL 레지스터에 복사
                                   ; CL 레지스터는 CX 레지스터의 하위 1바이트를 의미
                                   ; 문자열은 1바이트면 충분하므로 CX 레지스터의 하위 1바이트만 사용
    cmp cl, 0       ; 복사된 문자와 0을 비교
    je .MESSAGEEND  ; 복사한 문자의 값이 0이면 문자열이 종료되었음을 의미하므로 .MESSAGEEND로 이동하여 문자 출력 종료

    mov byte[es: di], cl    ; 0이 아니라면 비디오 메모리 어드레스 0xB800:di 에 문자를 출력

    add si, 1   ; SI 레지스터에 1을 더하여 다음 문자열로 이동
    add di, 2   ; DI 레지스터에 2를 더하여 비디오 메모리의 다음 문자 위치로 이동. 비디오 메모리는 (문자, 속성)의 쌍으로 구성되므로
    jmp .MESSAGELOOP

.MESSAGEEND:
    jmp $       ; 현재 위치에서 무한 루프 수행

MESSAGE1: db 'MINT64 OS Boot Loader Start', 0    ; 출력할 메시지 정의.
                                                 ; 마지막은 0으로 설정하여 .MESSAGELOOP 에서 문자열이 종료되었음을 알 수 있도록 함.

times 510 - ( $ - $$ )  db  0x00    ; $: 현재 라인의 어드레스
                                    ; $$: 현재 섹션 (.text)의 시작 어드레스
                                    ; $ - $$ : 현재 섹션을 기준으로 하는 오프셋
                                    ; 510 - ( $ - $$ ): 현재부터 어드레스 510 까지
                                    ; db 0x00: 1바이트를 선언하고 값은 0x00
                                    ; time: 반복 수행
                                    ; 현재 위치에서 어드레스 510 까지 0x00 으로 채움

db 0x55 ; 1 바이트를 선언하고 값은 0x55
db 0xAA ; 1 바이트를 언언하고 값은 0xAA
        ; 어드레스 511, 512 에 0x55, 0xAA 를 써서 부트섹터로 표기함
```

실행해 보면 화면이 깨끗히 지워지고 `MINT64 OS Boot Loader Start` 문자를 볼 수 있다.

```
qemu-system-x86_64 -L . -m 64 -hda ./Disk.img -localtime -display curses
```

