# 키보드 컨트롤러의 구조와 기능

키보드 컨트롤러는 PC 내부 버스(BUS)와 포트 I/O 방식으로 연결되어 있으며, 포트 어드레스는 `0x60`와 `0x64`를 사용한다. 
실제로 할당된 포트는 두 개지만 포트에서 데이터를 읽을 때와 쓸 때 접근하는 레지스터가 다르므로, 실제로는 네 개의 레지스터와 연결된 것과 같다.

**키보드와 마우스, 키보드 컨트롤러, PC의 관계**

![keyboard mouse relation](/contents/dev/2020/05/12/image/os-study-28-1.png)

#### I/O 포트와 키보드 컨트롤러 레지스터의 관계 (모두 1바이트)

**0x64 포트**

- 쓰기
- 컨트롤 레지스터
- 키보드 컨트롤러를 제어하는 레지스터


**0x64 포트**

- 읽기
- 상태 레지스터
- 키보드 컨트롤러의 상태를 나타내는 레지스터

**0x60 포트**

- 쓰기
- 입력 버퍼
- 프로세서가 키보드나 마우스로 보내는 커맨드 또는 데이터를 저장하는 레지스터

**0x64 포트**

- 읽기
- 출력 버퍼
- 키보드나 마우스가 프로세서로 보내는 데이터를 저장하는 레지스터

#### 상태 레지스터의 비트 구성과 의미

**7 비트**

- PARE 필드
- Parity Error 의 약자로 키보드나 마우스로 온 마지막 데이터에 패리티 에러가 발생했음을 의미
- 1로 설정되면 패리티 에러가 발생했음을 나타내며, 0으로 설정되면 패리티 에러가 발생하지 않았음을 나타냄

**6 비트**

- TIM 필드
- General Time-Out의 약자로 키보드 또는 마우스가 정해진 시간에 응답하지 않았음을 의미
- 1로 설정되면 타임 아웃이 발생했음을 나타내며, 0으로 설정되면 타임 아웃이 발생하지 않았음을 의미

**5 비트**

- AUXB 필드
- 출력 버퍼(Output)에 보조 디바이스(Auxiliary Device=마우스)의 데이터가 있음을 의미
- 1로 설정되면 마우스 데이터임을 나타내며, 0으로 설정되면 키보드 데이터임을 나타냄

**4 비트**

- KEYL 필드
- Keyboard Lock Status의 약자로 키보드가 잠겼는지(Lock) 여부를 설정
- 1로 설정되면 키보드가 잠겼음을 나타내고, 0으로 설정되면 키보드 데이터임을 나타냄

**3 비트**

- C/D 필드
- Command/Data의 약자로 마지막으로 송신된 데이터의 종류를 의미
- 1로 설정되면 마지막으로 송수신된 데이터가 커맨드(포트 0x64)임을 나타내고, 0으로 설정되면 데이터(포트 0x60)임을 나타냄

**2 비트**

- SYSF 필드
- System Flag의 약자로 Self-Test가 성공적으로 끝났는지 여부를 의미
- 1로 설정되면 Self-Test가 성공적으로 끝나서 사용 가능함을 나타내며, 0으로 설정되면 Power-On-Reset이 진행중임을 나타냄

**1 비트**

- INPB 필드
- Input Buffer State의 약자로 입력 버퍼에 프로세서가 쓴 데이터가 남아있는지 여부를 의미
- 1로 설정되면 키브도 컨트롤러가 아직 입력 버퍼의 데이터를 가져가지 않았음을 나타내며, 0으로 설정되면 컨트롤러가 데이터를 가져가서 키보드나 마우스로 전송하여 입력 버퍼가 비었음을 나타냄

**0 비트**

- OUTB 필드
- Output Buffer State의 약자로 출력 버퍼에 키보드 컨트롤러가 보낸 데이터가 남아있는지 여부를 의미
- 1로 설정되면 키보드 컨트롤러가 키보드 또는 마우스에서 수신한 데이터가 출력 버퍼에 있음을 나타내며, 0으로 설정되면 프로세서가 데이터를 가져가서 출력 버퍼가 비어있음을 나타냄

#### 키보드와 마우스, 기타 시스템 제어에 관련된 키보드 컨트롤러 커맨드

**0x20**

- 키보드 컨트롤러의 커맨드 바이트를 출력 버퍼(0x60)로 복사
- 비트 1: 1로 설정하면 마우스 인터럽트 활성화
- 비트 0: 1로 설정하면 키보드 인터럽트 활성화

**0x60**

- 입력 버퍼(포트 0x60)에 쓴 값을 키보드 컨트롤러의 커맨드 바이트로 복사
- 비트 1: 1로 설정하면 마우스 인터럽트 활성화
- 비트 0: 1로 설정하면 키보드 인터럽트 활성화

**0xA7**

- 마우스 디바이스를 비활성화

**0xA8**

- 마우스 디바이스를 활성화

**0xAD**

- 키보드 디바이스를 비활성화

**0xAE**

- 키보드 디바이스를 활성화

**0xD0**

- 키보드 컨트롤러의 출력 포트 값을 출력 버퍼(포트 0x60)로 복사
- 비트 1: 1로 설정하면 A20게이트 활성화
- 비트 0: 0으로 설정하면 프로세서 리셋(PC 리부팅)

**0xD1**

- 입력 버퍼(포트 0x60)에 쓴 값을 키보드 컨트롤러의 출력 포트로 복사
- 비트 1: 1로 설정하면 A20게이트 활성화
- 비트 0: 0으로 설정하면 프로세서 리셋(PC 리부팅)

**0xD4**

- 입력 버퍼(포트 0x60)에 쓴 값을 마우스 디바이스로 송신

# 키보드와 키보드 컨트롤러 활성화

일반적으로 부트 로더가 실행되기 전에 키보드는 이미 BIOS에 의해서 활성화된 상태이다. 따라서 키보드를 활성화하는 단계를 굳이 수행하지 않아도 키보드에서 키 값을 읽는데 아무 문제가 없다.
하지만, 어디까지나 일반적인 상황이므로, 만약을 대비해서 키보드를 직점 활성화해 보자.

키보드 컨트롤러에서 키보드 디바이스를 사용 가능하게 하려면, 커맨드 포트로 키보드 디바이스 활성화 커맨드인 `0xAE`를 보내면 된다. 
하지만 이것은 키보드 컨트롤러에서 활성화된 것이지 실제 키보드가 활성화된 것은 아니다.
키보드 컨트롤러와 키보드는 PS/2 방식의 케이블로 연결되어 있으며 PC의 외부에 존재하기 때문에 키보드에도 활성화 커맨드를 보내줄 필요가 있다.

키보드에 직접 데이터를 보내는 방법은 커맨드를 전송하지 않고, 입력 버퍼에 키보드로 보낼 커맨드를 직접 쓰면 된다.
키보드는 키보드 컨트롤러와 달리 커맨드나 데이터에 대한 응답이 전송되며, 정상적으로 처리한 경우 ACK(0xFA)를 전송한다.
만일 ACK가 수신되지 않으면 수행 도중 에러가 발생한 것이므로, 재시도하거나 작업을 포기해야 한다.

#### LED와 키보드 활성화에 관련된 키보드 커맨드

0xED

- 키보드의 LED 상태를 변경
- 비트 2: 1로 설정하면 Caps Lock 켜짐
- 비트 1: 1로 설정하면 Num Lock 켜짐
- 비트 0: 1로 설정하면 Scroll Lock 켜짐

0xF4

- 키보드 활성화

키보드와 키보드 컨트롤러는 프로세서와 비교하면 아주 느리게 동작하므로 프로세서가 커맨드를 전송하고 한참을 기다려야 수행이 완료된다.
여기서 문제는 커맨드가 완료될 때까지 얼마나 기다려야 하는 가이다.
커맨드를 처리하는 사간은 키보드와 키보드 컨트롤러의 상태에 따라 가변적인 부분이다.
그러므로 키보드 컨트롤러의 상태를 확인할 수 있는 무언가가 필요한데 이것이 키보드 컨트롤러의 상태 레지스터(포트 0x64)이다.

상태 레지스터는 입력 버퍼 상태를 표시하는 비트(비트 1)와 출력 버퍼의 상태를 표시하는 비트(비트 0)가 있다.
입력 버퍼 상태 비트(비트 1)를 통해 입력 버퍼가 비었는지 확인 후 키보드 커맨드를 송신하고, 출력 버퍼 상태가 비트(비트 0)을 통해 출력 버퍼에 데이터가 있는지 확인한 후
실행 결과를 읽음으로써 보다 효율적으로 처리할 수 있다.

**키보드 컨트롤러와 키보드를 활성화하는 코드**
```
// 출력 버퍼(포트 0x60)에 수신된 데이터가 있는지 여부를 반환
BOOL kIsOutputBufferFull(void)
{
	// 상태 레지스터(포트 0x64)에서 읽은 값에 출력 버퍼 상태 비트(비트 0)가
	// 1로 설정되어 있으면 출력 버퍼에 키보드가 전송한 데이터가 존재함
	if (kInPortByte(0x64) & 0x01)
	{
		return TRUE;
	}
	return FALSE;
}

// 입력 버퍼(포트 0x64)에 프로세서가 쓴 데이터가 남아있는지 여부를 반환
BOOL kIsInputBufferFull(void)
{
	// 상태 레지스터(포트 0x64)에서 읽은 값에 입력 버퍼 상태 비트(비트 1)가
	// 1로 설정되어 있으면 아직 키보드가 데이터를 가져가지 않았음
	if (kInPortByte(0x64) & 0x02)
	{
		return TRUE;
	}
	return FALSE;
}

// 키보드를 활성화
BOOL kActivateKeyboard(void)
{
	int i;
	int j;

	// 컨트롤 레지스터(포트 0x64)에 키보드 활성화 커맨드(0xAE)를 전달하여 키보드 디바이스 활성화
	kOutPortByte(0x64, 0xAE);

	// 입력 버퍼(포트 0x60)가 빌 때까지 기다렸다가 키보드에 활성화 커맨드를 전송
	// 0xFFFF만큼 루프를 수행할 시간이면 충분히 커맨드가 전송될 수 있음
	// 0xFFFF 루프를 수행한 이후에도 입력 버퍼(포트 0x60)가 비지 않으면 무시하고 전송
	for(i = 0; i < 0xFFFF; i++)
	{
		// 입력 버퍼(포트 0x60)가 비어있으면 키보드 커맨드 전송 가능
		if (kIsInputBufferFull() == FALSE)
		{
			break;
		}
	}

	// 입력 버퍼(포트 0x60)로 키보드 활성화(0xF4) 커맨드를 전달하여 키보드로 전송
	kOutPortByte(0x60, 0xF4);

	// ACK가 올 때까지 대기함
	// ACK가 오기 전에 키보드 데이터를 최대 100개까지 수신하여 ACK를 확인
	// ACK가 전달되기 전에 몇몇 키 값이 이미 출력 버퍼에 들어 있을 수 있기 때문에 100회 동안 ACK를 찾을 때 까지 데이터를 소비한다.
	for(j = 0; j < 100; j++)
	{
		// 0xFFFF만큼 루프를 수행할 시간이면 충분히 커맨드의 응답이 올 수 있음
		// 0xFFFF 루프를 수행한 이후에도 출력 버퍼(포트 0x60)가 차있지 않으면 무시하고 읽음
		for (i = 0; i< 0xFFFF; i++)
		{
			if (kIsOutputBufferFull() == TRUE)
			{
				break;
			}
		}

		// 출력 버퍼(포트 0x60)에서 읽은 데이터가 ACK(0xFA)이면 성공
		if (kInPort(0x60) == 0xFA)
		{
			return TRUE;
		}
	}

	return FALSE;
}
```

**kInPortByte() 함수와 kOutPortByte()함수의 코드**
```
; 포트로부터 1바이트를 읽음
; PARAM: 포트 번호
KInPortByte:
    push rdx        ; 함수에서 임시로 사용하는 레지스터를 스택에 저장
                    ; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

    mov rdx, rdi    ; RDX 레지스터에 파라미터 1(포트 번호)를 저장
    mov rax, 0      ; RAX 레지스터를 초기화
    in al, dx       ; DX 레지스터에 저장된 포트 어드레스에서 한 바이트를 읽어 AL 레지스터에 저장
                    ; AL 레지스터는 함수의 반환 값으로 사용됨
                    ; 포트 I/O 어드레스에서 데이터를 읽어오는 명령어

    pop rdx         ; 함수에서 사용이 끝난 레지스터를 복원
    ret             ; 함수를 호출한 다음 코드의 위치를 복귀

; 포트에 1바이트를 씀
; PARAM: 포트 번호, 데이터
kOutPortByte:
    push rdx        ; 함수에서 임시로 사용하는 레지스터를 스택에 저장
    push rax        ; 함수의 마지막 부분에서 스택에 삽입된 값을 꺼내 복원

    mov rdx, rdi    ; RDX 레지스터에 파라미터 1(포트 번호)를 저장
    mov rax, rsi    ; RAX 레지스터에 파라미터 2(데이터)를 저장
    out dx, al      ; DX 레지스터에 저장된 포트 어드레스에 AL 레지스터에 저장된 한 바이트를 씀
                    ; 포트 I/O 어드레스에 데이터를 쓰는 명령어

    pop rax         ; 함수에서 사용이 끝난 레지스터를 복원
    pop rdx
    ret             ; 함수를 호출한 다음 코드의 위치로 복귀
```

위의 코드를 보면 보호 모드와 달리 파라미터를 스택에 넘겨받지 않고 RDI나 RSI 레지스터로 넘겨 받는다는 것을 알 수 있다.
이는 보호 모드와 IA-32e 모드의 함수 호출 규약이 서로 다르기 때문이다.

## IA-32e 모드의 호출 규약

IA-32e 모드의 C 호출 규약과 보호 모드의 C 호출 규약을 비교하면 크게 3가지 부분에서 차이가 난다.

첫 번째 차이는 파라미터를 전달할 때 레지스터를 우선으로 사용한다는 것이다.
파라미터로 사용하는 레지스터는 파라미터의 타입에 따라 다른데 정수 타입의 경우 RDI, RSI, RDX, RCX, R8, R9 레지스터의 순서로 모두 6개로 사용하며,
실수 타입의 경우는 XMM0 ~ XMM7 레지스터의 순서로 모두 8개를 사용한다. 
파라미터의 수가 정해진 레지스터의 수를 넘으면 보호 모드와 마찬가지로 스택 영역을 사용한다.

두 번째 차이는 레지스터 또는 스택에 파라미터를 삽입하는 순서이다.
보호 모드의 경우 파라미터 리스트의 오른쪽에서 왼쪽으로 이동하면서 파라미터를 스택에 삽입했다. 
하지만 64비트 모드에서는 파라미터 리스트의 왼쪽에서 오른쪽으로 이동하면서 레지스터나 스택을 사용하여 삽입한다.

세 번째 차이는 함수의 반환 값으로 사용하는 레지스터이다. 보호 모드는 EAX 레지스터를 사용하여 반환 값을 처리하지만,
64비트 모드는 정수 타입이면 RAX 또는 RAX와 RDX 레지스터를 사용하고 실수 타입은 XMM0 또는 XMM0과 XMM1 레지스터를 사용한다.
(MXX0~7 레지스터는 실수 연산에 관련된 FPU(Floating Point Unit)에 관련된 레지스터이다.)

