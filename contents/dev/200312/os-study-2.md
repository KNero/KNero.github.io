여기서는 본격적인 개발에 앞서 OS 의 간단한 이론을 정리하고 지나가려고 한다. 개발에 꼭 필요한 부분이기 때문에 알고 가보자.
아마 앞으로 개발하다가 이 부분을 다시 읽어보는 경우가 많을 듯 싶다.

# 운영 모드

인텔 64비트 호환 프로세서(x86-64 프로세서)에는 크게 다섯 가지 운영 모드가 있다.

- 리얼 모드 : 프로세서 초기 단게로 16비트 모드로 동작. 8086 프로세서와 호환. 최대 1MB(2^20)의 주소 공간을 지원
- 보호 모드 : 32비트 모드로 동작. 세그먼트, 페이징, 보호, 멀티태스킹 등을 제공. 최대 4GB(2^32)의 주소 공간을 지원
- IA-32e 모드 : 32비트 호환 모드와 64비트 모드 두 가지 서브모드로 구성. 16EB(2^54)의 주소 공간을 지원 (AMD 에서는 Long Mode 로 표기)
- 시스템 관리 모드 : 전원 관리, 하드웨어 제어 같은 특수 기능 제공
- 가상 8060 모드 : 보호 모드 내부에서 가상의 환경을 설정하여 리얼 모드처럼 동작.

이중 64비트 OS 가 반드시 지원해야 하는 세 가지 모드는 **리얼 모드, 보호 모드, IA-32e 모드의 64비트 서브모드** 이다.

## 리얼 모드

전원이 켜지거나 리셋되면 프로세서는 리얼 모드로 진입하고 과거의 16비트 프로세서와 동일하게 동작한다. 
BIOS(Basic Input Output System)의 여러 기능을 사용할 수 있으며 OS 의 이미지를 디스크에서 메모리로 복사하여 보호 모드로 변경하는 것을 한다.
그리고 대부분 어셈블리어로 작성된다.

## 보호 모드

리얼 모드에서 IA-32e 모드로 전환되기 위해 반드시 거쳐가야 하는 모드로 32비트 윈도우나 리눅스 OS가 동작하는 기본 모드이다.
우리가 항상 들어왔던 최대 4G의 주소 공간을 제공하고 필수 기능인 보호, 멀티태스킹, 세그먼테이션, 페이징 등이 있다.
보호 모드에서 사용하는 레지스터는 대부분 IA-32e 모드에서도 같이 사용하므로 보호 모드를 이해하는 것은 매우 중요하다.

## IA-32e 모드

최대 16E의 주소 공간을 제공하며 레지스터 수도 보호 모드보다 많다. 
서브 모드를 32비트 호환 모드로 변경하면 보호 모드에 있는 것처럼 동작하게 되므로 32비트 코드를 그대로 실행할 수 있다.

## 운영 모드 전환

### 전원 -> IA-32e 모드

1. 전원
2. 리얼 모드
3. CR0 레지스터의 PE 비트 1로 설정
4. 보호 모드
5. CR0 레지스터의 PG 비트를 1로 설정, CR4 레지스터의 PAE 비트를 1로 설정, IA32_EFER MSR 레지스터의 LME 비트를 1로 설정
6. IA-32e 모드

### IA-32e 모드 -> 리얼모드 Case1

1. IA-32e 모드
2. IA32_EFER MSR 레지스터의 LME 비트를 0으로 설정
3. 보호 모드
4. CR0 레지스터의 PE 비트를 0으로 설정, 리셋
5. 리얼 모드

### IA-32e 모드 -> 리얼모드 Case2

1. IA-32e 모드
2. 리셋
3. 리얼 모드

모드를 전환하기 위한 필요 조건들로 컨트롤 레지스터와 인터럽트만 표시했지만 기본적으로 각 모드에 필요한 자료구조는 미리 설정되어 있어야 한다.

# 레지스터 

## 보호 모드의 레지스터

### 프로그램 실행에 관련된 기본 레지스터
- 32비트 범용 레지스터 : EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP
- 인스트럭션 포인트 레지스터 : 32비트 EIP
- 16비트 세그먼트 레지스터 : CS, DS, ES, FS, GS, SS

### 실수 연산 및 SIMD 관련 레지스터
- 80비트 FPU 레지스터 (8개)
- 64비트 MMX 레지스터(8개)
- 128비트 XMM 레지스터(8개)

### 시스템에 관련되 레지스터
- 32비트 컨트롤 레지스터 : CR0, CR1, CR2, CR3, CR4
- 플래그 레지스터 : 32비트 EFLAGS
- 글로벌 디스크립터 테이블 레지스터 : 48비트 GDTR
- 인터럽트 디스크립터 테이블 레지스터 : 48비트 IDTR
- 로컬 디스크립터 테이블 레지스터 : 16비트 LDTR
- 태스크 레지스터 : 16비트 TR
- 모델 고유 레지스터 : MSR

## IA-32e 모드의 레지스터

### 프로그램 실행에 관련된 기본 레지스터
- 64비트 범용 레지스터 : RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP, R8 ~ R15
- 인스트럭션 포인트 레지스터 : 64비트 RIP
- 16비트 세그먼트 레지스터 : CS, DS, ES, FS, GS, SS

### 실수 연산 및 SIMD 관련 레지스터
- 80비트 FPU 레지스터 (8개)
- 64비트 MMX 레지스터(8개)
- 128비트 XMM 레지스터(8개)

### 시스템에 관련되 레지스터
- 64비트 컨트롤 레지스터 : CR0, CR1, CR2, CR3, CR4, CR8
- 플래그 레지스터 : 64비트 RFLAGS
- 글로벌 디스크립터 테이블 레지스터 : 80비트 GDTR
- 인터럽트 디스크립터 테이블 레지스터 : 80비트 IDTR
- 로컬 디스크립터 테이블 레지스터 : 16비트 LDTR
- 태스크 레지스터 : 16비트 TR
- 모델 고유 레지스터 : MSR

개발하는 과정에서 가장 중요한 레지스터는 **범용 레지스터, 세그먼트 레지스터, 컨트롤 레지스터** 이다.

## 범용 레지스터

계산, 메모리 어드레스 지정, 임시 저장 공간 등의 목적으로 사용하며 범용이기 때문에 다양한 목적으로 사용될 수 있다.
x86-64 프로세서는 64비트 크기의 범용 레지스터만 있으면 각 모드에서는 레지스터의 일부분만을 사용하는 방식으로 처리한다.
(하위 32비트, 하위 16비트, 하위 8비트의 크기로 구분하여 접근)
또한 EAX, EBX 의 `E` 나 RAX, RBX 의 `R` 은 32비트 64비트의 접두사이다.

| 범용 레지스터 이름 | 용도  |
| ------------- |-------------|
| AX | 산술 연산을 수행할 때 누산기로 사용 |
| BX | 데이터의 어드레스를 지정할 때 데이터 포인터로 사용 |
| CX | 루프 또는 문자열의 카운터로 사용 |
| DX | I/O 어드레스를 지정할 때 사용되며, 산술 연산을 수행할 때 보조 레지스터로 사용 |
| SI | 문자열에 관련된 작업을 수행할 때 원본 문자열의 인덱스로 사용 |
| DI | 문자열에 관련된 작업을 수행할 때 목적지 문자열의 인덱스로 사용 |
| SP | 스택의 포인터로 사용 |
| BP | 스택의 데이터에 접근할 때 데이터의 포인터로 사용 |
| R8 ~ R15 | x86-64 프로세서에서 추가된 범용 레지스터로, 다양한 용도로 사용 가능 |

## 세그먼트 레지스터

16비트의 레지스터로 어드레스 영역을 다양한 크기로 구분하는 역할을 한다. 리얼 모드에서는 단순히 고정된 크기의 어드레스 영역을 지정하는 역할만 하지만
보호 모드와 IA-32e 모드에서는 접근 권한(Privilege Level), 세그먼트의 시작 어드레스와 크기 등을 지정하는데 사용되기도 한다.

### CS

- 코드 영역을 가리킨다.
- 데이터 이동 명령으로 값을 변경할 수 없으며, 점프 명령이나 인터럽트 관련 명령으로 변경가능

### DS, ES, FS, GS

- 데이터 영역을 가리키는 레지스터
- 데이터 이동 명령으로 값을 벼경할 수 있음
- DS 레지스터는 데이터 영역에 접근할 때 암시적으로 사용됨
- ES 레지스터는 문자열과 관련된 작업을 처리할 때 암시적으로 사용됨
- 데이터 영역에 접근하면서 DS 레지스터 이외의 세그먼트 레지스터를 사용하려면 세그먼트 레지스터 접두사 사용

### SS

- 스택 영역을 가리키는 레지스터
- 데이터 이동 명령으로 값을 변경할 수 있음
- 스택 관련 레지스터(SP, BP)를 통해 스택에 접근할 때 암시적으로 사용됨

## 컨트롤러 레지스터

운영 모드를 변경하고, 현재 운영 중인 모드의 특정 기능을 제어하는 레지스터로 x86 프로세서는 5개, x86-64 는 6개의 컨트롤 레지스터가 있다.

| 컨트롤 레지스터 이름 | 용도 |
| --------------- | --- |
| CR0 | 운영 모드를 제어 |
|     | 리얼 모드에서 보호 모드로 전환하는 역할과 캐시, 페이징 기능을 활성화시킴 |
| CR1 | 프로세서에 의해 예약된 레지스터 |
| CR2 | 페이지 폴트 발생 시 페이지 폴트가 발생한 선형 주소가 저장되는 레지스터 |
|     | 페이징 기법을 활성화한 후에는 페이지 폴트 발생 시만 유효한 값을 가짐 |
| CR3 | 페이지 디렉터리의 물리 주소와 페이지 캐시에 관련된 기능을 설정하는 레지스터 |
| CR4 | 프로세서에서 지원하는 각종 확장 기능을 제어하는 레지스터 |
|     | 페이지 크기 활장이나 메모리 영역 확장 등의 기능을 활성화시킴 |
| CR8 | 태스크 우선순위 레지스터의 값을 제어하는 레지스터 |
|     | 프로세스 외부에서 발생하는 인터럽트를 걸러주는 필터의 역할 |
|     | IA-32e 모드에서만 접근 가능 |
